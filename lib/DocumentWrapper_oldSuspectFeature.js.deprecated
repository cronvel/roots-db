







			/* Old 'Suspect' document... */

//*
// Should probably have its instance type of its own
function oldDocumentWrapper( collection , rawDocument , options )
{
	// [...]
	
	var wrapper , deepInherit ;
	
	// Suspect is set when the object is in a state where it may exist upstream but should be loaded first
	if ( options.suspected )
	{
		wrapper.suspected = true ;
		wrapper.upstream = deepInherit( null , collection.suspectedBase ) ;
		wrapper.$ = deepInherit( null , wrapper.upstream ) ;
		wrapper.id = null ;
		wrapper.fingerprint = null ;
		wrapper.witness = null ;
		
		Object.defineProperty( wrapper.$ , '' , { value: wrapper } ) ;	// link to the parent
		
		if ( options.fingerprint && typeof options.fingerprint === 'object' )
		{
			var fingerprint ;
			
			// Check if we have a unique fingerprint
			if ( options.fingerprint instanceof rootsDb.FingerprintWrapper ) { fingerprint = options.fingerprint ; }
			else { fingerprint = this.createFingerprint( options.fingerprint ) ; }
			
			if ( fingerprint.unique )
			{
				tree.extend( { own: true } , wrapper.upstream , fingerprint.partialDocument ) ;
				//console.log( '<<<<<<<<<< wrapper.upstream:' , wrapper.upstream ) ;
				wrapper.fingerprint = fingerprint ;
			}
		}
		
		if ( options.witness && typeof options.witness === 'object' && Object.keys( options.witness ).length )
		{
			wrapper.witness = options.witness ;
		}
		
		if ( options.id )
		{
			if ( typeof options.id !== 'string' && ! options.id.toString ) { throw new Error( '[roots-db] provided id cannot be converted to a string' ) ; }
			Object.defineProperty( wrapper , 'id' , { value: collection.driver.createId( wrapper.$ , options.id ) , enumerable: true } ) ;
		}
		
		if ( ! wrapper.id && ! wrapper.fingerprint && ! wrapper.witness )
		{
			throw new Error( '[roots-db] cannot instanciate a suspect without id, fingerprint or witness' ) ;
		}
		
		return wrapper ;
	}
}



// Reveal a suspected Document
DocumentWrapper.prototype.reveal = function documentReveal( options , callback )
{
	if ( ! options || typeof options !== 'object' )
	{
		if ( typeof options === 'function' ) { callback = options ; }
		options = {} ;
	}
	
	if ( typeof callback !== 'function' ) { callback = noop ; }
	
	if ( ! this.suspected || ( options.idOnly && this.id ) ) { callback( undefined , this ) ; return ; }
	
	if ( this.id ) { this.revealById( options , callback ) ; return ; }
	
	if ( this.fingerprint ) { this.revealByFingerprint( options , callback ) ; return ; }
	
	if ( this.witness ) { this.revealByWitness( options , callback ) ; return ; }
} ;



DocumentWrapper.prototype.revealById = function documentRevealById( options , callback )
{
	var idString , deepInherit = this.collection.deepInherit , self = this ;
	
	if ( typeof this.id === 'string' ) { idString = this.id ; }
	else if ( this.id.toString ) { idString = this.id.toString() ; }
	else { throw new Error( '[roots-db] provided id cannot be converted to a string' ) ; }
	
	this.collection.driver.get( this.id , function( error , rawDocument ) {
		
		if ( error ) { callback( error ) ; return ; }
		
		if ( ! rawDocument )
		{
			self.suspected = false ;
			self.deleted = true ;
			self.upstreamExists = false ;
			callback( ErrorStatus.notFound( { message: 'Document not found' } ) ) ;
			return ;
		}
		
		self.suspected = false ;
		self.loaded = true ;
		self.upstreamExists = true ;
		
		self.upstream = deepInherit( rawDocument , self.collection.documentBase ) ;
		deepInherit( self.$ , self.upstream ) ;
		delete self.$[ self.collection.driver.idKey ] ;
		
		callback( undefined , self ) ;
	} ) ;
} ;



DocumentWrapper.prototype.revealByFingerprint = function documentRevealByFingerprint( options , callback )
{
	var deepInherit = this.collection.deepInherit , self = this ;
	
	if ( ! ( this.fingerprint instanceof rootsDb.FingerprintWrapper ) ) { throw new Error( '[roots-db] no fingerprint for this suspect' ) ; }
	
	this.collection.driver.getUnique( this.fingerprint.$ , function( error , rawDocument ) {
		
		if ( error ) { callback( error ) ; return ; }
		
		if ( ! rawDocument )
		{
			self.suspected = false ;
			self.deleted = true ;
			self.upstreamExists = false ;
			callback( ErrorStatus.notFound( { message: 'Document not found' } ) ) ;
			return ;
		}
		
		self.suspected = false ;
		self.loaded = true ;
		self.upstreamExists = true ;
		
		self.upstream = deepInherit( rawDocument , self.collection.documentBase ) ;
		deepInherit( self.$ , self.upstream ) ;
		delete self.$[ self.collection.driver.idKey ] ;
		
		callback( undefined , self ) ;
	} ) ;
} ;



DocumentWrapper.prototype.revealByWitness = function documentRevealByWitness( options , callback )
{
	var self = this ;
	
	if ( ! this.witness || typeof this.witness !== 'object' ) { throw new Error( '[roots-db] no witness for this suspect' ) ; }
	
	switch ( this.witness.type )
	{
		case 'link' :
			if ( this.witness.document.suspected )
			{
				// Do not transmit options.idOnly
				this.witness.document.reveal( {} , function( error ) {
					if ( error ) { callback( error ) ; return ; }
					self.revealByWitness( options , callback ) ;
				} ) ;
				
				return ;
			}
			
			if ( ! this.witness.document.$[ this.witness.property ] )
			{
				this.deleted = true ;
				callback( ErrorStatus.notFound( { message: 'Document not found' } ) ) ;
				return ;
			}
			
			this.id = this.witness.document.$[ this.witness.property ] ;
			
			if ( options.idOnly ) { callback( undefined , this ) ; return ; }
			
			this.revealById( options , callback ) ;
			
			break ;
		
		// those type cannot exist for a document:
		//case 'backlink' :
		default :
			throw new Error( '[roots-db] Cannot reveal batch with this type of witness: ' + this.witness.type ) ;
	}
} ;



// Useful?
// Return a one-value state
DocumentWrapper.prototype.state = function documentState()
{
	if ( this.deleted ) { return 'deleted' ; }
	
	if ( this.suspected )
	{
		if ( this.upstreamExists ) { return 'existing-suspect' ; }
		return 'suspected' ;
	}
	
	if ( this.upstreamExists )
	{
		if ( ( this.saved || this.loaded ) && Object.keys( this.$ ).length === 0 ) { return 'synced' ; }
		return 'exists' ;
	}
	
	return 'app-side' ;
} ;

//*/


